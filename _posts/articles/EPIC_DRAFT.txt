Built for change.
How to make a modern website.

A website is not a precious artifact. It's a tool. A good website serves a purpose. Perhaps the purpose is to generate revenue, build engagement, or provide information to a target audience. Regardless of purpose, it likely has a group of people who are in some way responsible for its existence. They manage the continual stream of requests and ideas to update and improve the site. Like it or not, whether it's at a start-up or a mom-and-pop shop, most websites are in a constant state of change. Rarely is a website ever complete. Admitting that reality is the first step. The second step is to learn about some of the techniques used to make the site easy to change.

Years ago, the solution to this problem would have been to create a CMS (Content Management System), which is basically the functionality of word press [link], customized and built for a particular site. The idea was that if the team builds the perfect artifact--one that allows for some level of dynamic change--the team that the site is built for will *inevitably* be empowered to make changes to the site, and therefore, get more mileage out of the artifact. In some cases, this might work, but unless the scope and tactics are clearly defined ahead of time (which *never* happens), the team will end up with costly updates, complicated code and countless bugs.

In some cases, the light-CMS approach might be helpful. Let's say you're a law firm and you occasionally update the staff section of an otherwise static website. In that case, what was just described may be the perfect solution. If you're a product team at a software company and need a site that is dynamic and constantly being optimized to suit the ever-changing needs of a growing user base (or in some cases the goals of an executive team), what you'll need is a site that is built using modern methods that allow changes to be integrated more efficiently.

Web standards have paved the way for techniques that we can use to build websites in a smarter and more durable way. Long story short, for those non-nerds out there, *web standards* are basically an evolving set of rules or guidelines by the people who make the tools, browsers, text editors, applications, rendering engines, etc. that are used to make and view websites. That way, developers can rely on a certain, *standard* way to build things out so everything can play nicely together. In many cases, it's the difference between building a house with everything from scratch--cutting the trees, foraging your own steel, blowing your own glass, or building a house with standardized parts you bought from Home Depot. 

A couple of decades ago, we weren't there yet, and now, for the most part, the standards have been implemented and will continue to change and develop over time, with the majority of stakeholders on the same-ish page. However, as is the case for all design, development, engineering, what-have-yous, web standards are only one step in a larger continual evolution.


1. Define the layout globally

The first item in this evolution is the standard grid system. This is not just referring to the esoteric Swiss concept of [grid based layout:link], it's actually coding the website using a standardized modular layout. The code used is sometimes called *scaffolding* because it establishes global structural elements that apply to every page on the site. The elements can be called and defined, as needed, instead of each being defined from scratch in every instance. 

For example, the code globally defines how wide the page will be, and the maximum number of columns. In this particular design, there are three different page types. One for home, one for body info, and one for the contact form. On the home page, there are three images that appear in three evenly divided columns, the body info page has a two-thirds column and a one-third column, and on the contact form, there is one big column that has a contact form.

Instead of hard-coding the varying widths of each of the items and laying them out individually from scratch, the code establishes three basic columns and defines each element in relation to what's been defined globally. So in this case, it would be the home page with three single column span, a page with a two column span next to a one column span, and a three column span on the contact page. 

By defining the page structure globally, there is less opportunity for rogue layouts to get added to the site as in cases where everything is built from scratch. It's easy to make a mistake or even to justify deviation when everything is built piece-by-piece. Using modular code, based on a thought out grid system helps ensure the end result will be consistent and easier to rearrange later if need be.


2. Use modular interface elements
It's not about designing a website. It's about designing a UI. The most important problem to solve when designing a website is coming up with a system of components and templates that can be mixed, matched and re-arranged at any given time in order to affect tactical change. The most crippling issue faced with those tasked to manage a website is an inability to make rapid changes. An approach to this issue is to specifically design a system of modular components. A modular UI system contains 3 useful pieces, components, content modules and layouts.

Components are the nuts and bolts of the system. They are the buttons, form elements, images and headline treatments that are used throughout the user-interface. It's important that the UI components are durable and fit nicely into the space that is provided for them in the scaffolding. For example, since you've already established a grid-based scaffolding system, each button should be built so that it will take up 100% of the width of it's containing div area. That way the width is determined by the scaffolding and not the element and can be used interchangeably in whatever layout is needed, without the need for custom code or hacks.

Content modules are basically a few components arranged in a certain configuration, designed to fulfill a specific purpose. For content modules, it's effect to name them based on what the element is supposed to drive. This is a subtle level of "semantics" that can be overlooked when developers and designers quibble about what class names to use in the code. Referring to this piece based on its purpose helps it transcend component the mere component status to an instrument--a tool--or driver of action. For example, a layout area that contains a div that spans 100% of the width of the window, that is 350px high and contains a button in the center should not be called "rectangle with centered button," but instead should be called something like, "conversion area." This implies that the purpose of that particular configuration is to drive a clear and specific call to action. Other content modules may include: list items, feature call-outs, content highlights. Each one is a specific piece that will be mixed and matched to create different layouts.

Layouts are basically arrangements of content modules that are used to drive a specific call to action or tell a certain story. For example, a Product Page might include a Conversion Area at the top, followed by several Feature Call-Outs with another Conversion Area at the bottom. If the system is truly modular, each page should be part of an established layout template, with each layout containing a specific arrangement of content modules. Using a system like that helps the team break down and understand the functionality of each piece at each layer, ultimately allowing the team to focus on the most important part, the flow of activity.

3. Design for the user's action, not the demographic
A user flow is not a site map. It doesn't describe the way that a website is built out or how the nav is organized. It's a step by step description of how a user moves through the site. While it's true that not everyone will move through a site in the same exact way, that doesn't mean they cannot be encouraged to move in a certain direction. The hierarchy of elements placed on a layout can significantly determine how people will interact with it. In order to effectively drive action, flows should be mapped out based on activity, not demographics.

Many times, discussions about *users* will circle back to demographics. "Fun-loving, cat owners, aged 43-67, living in cities that begin with the letter M" might very well move through a site differently than "sour-faced, porcelain collectors, aged 14-31, living in small towns in blue states," but their demographic is not the factor that should be considered. The reason why those folks move through sites differently is because they have different motivations and therefore are taking different actions. Therefore a better action-based profile would be "mobile web user in russia, wanting to send a 50 megabyte picture to a group of 20 close contacts." That's something that might have an impact on the way the site or app should be designed. The "mobile web user" indicates that the layout must work at a small screensize, the location to queue an language feature, the large photo to provide an interface to access the image taken with the phone, etc. While demographics might provide some insight about how or why, the action-based profile is more directly related to the users immediate needs. 
 
4. Make the site responsive and adaptive
Responsive web site design is the latest craze, but with good reason. With the multiplicity of screens we can expect in normal user work flow patterns, we can expect that content of a particular site will be viewed on many different screen size. So, basing the features of a particular layout on screen size is a pretty good idea. 

The trick with responsive design is to keep it simple. I'd say, 1 or 2 breakpoints tops. A breakpoint is a threshold, usually a particular point in the width of a layout. For example at the largest size, all of the elements on the page show up like any other page, with items arranged in columns on a grid. When the window is re-sized below a certain point, like let's say, below 580px wide, all of the elements stack up and down, and buttons become larger, so if someone is looking at the page on a cell phone, it would be easier for them to read and interact with the content on the page. I've noticed that many of the layout frameworks out there contain multiple breakpoints for different devices and versions. I say that's too complicated. Just pick one break point, such as the 580px, and go with it. It's much simpler and cleaner that way. If you're above this threshold, show the whole layout, otherwise stack everything...

An adaptive site is a site that contains logic to detect specific platforms and devices. Upon detection, messaging or features might change depending on which platform or device the user is viewing the content. For example, in an adaptive website, you might detect if someone is on Android, and redirect Android users to a page that specifically contains information for Android users. 

There are many places where this is useful. Screenshots and product imagery can then be tailored to match with various platforms and devices while specific messaging can be provided to a subset of users. If the detection system is coded in a modular way, it can be even more useful for managing user flow patterns. Let's say you have a primary conversion funnel to get people to download a PC-based product that will soon be available on Mac. If an adaptive system is available to the website team, an alternative flow can easily be provided, perhaps re-directing the user to a sign up page for the Mac version. 

Adaptive detection help round out the modular system. A useful tool, like plumbers puddy. Because the site is and should be in a constant state of flux, it's ever important to develop techniques to easily select out specific user profiles and provide them with tailored content. Coupling adaptive selectors with modal dialogs can be a great way to cobble together alternative flows for specific platforms or devices. With all this flux, the it is of utmost importance to establish a systematic way to track user activity among the various configurations.


5. Track events and test out ideas
The final item is to establish an event tracking schema. In this case, events are basically the trackable actions that occur on a web page such as clicks, hovers, and javascript events such as form submissions and more. Tools such as google analytics allow the developer to set up custom events in addition to other various handy metrics such as visits, time spent on page and traffic sources. 

Setting up a custom event allows you to track a particular event such as the amount of times a user clicks on button or link. For each event there is a string of text that will be used to identify the event in the analytics tool. The string is called a tag, and it's important to establish a naming convention for the various tags that will be used for different events. For example, I like to include the page, area of page, type of activity and item name on each event so the string ends up as something like: "HomePage-MainCTA-Click-MAIN_CTA_BTN". In addition to this, I provide put the events in a category with a unique name/number so that they all appear in the same bucket. That way if there is ever a major change, or I want to set up an alternative test bucket, I can change the category ID so that it will appear in a different bucket.

The idea is that if you tag your custom events consistently, you can more easily access the information, so you can develop a dashboard of stats to which you can refer. A dashboard is a collection of metrics used to measure progress on a specific initiative. For example, you can build a dashboard out of a list of custom events you use for your primary conversion funnel. By having a consistent naming system, you can use it when comparing different designs or different versions.

A good site is a site that is built to change. It should be a framework that serves to encourage action and engagement. Variations in user behavior and strategy require new user flows to be tested and vetted. A responsive grid system and modular, interchangeable, UI elements, combined with techniques for platform detection and event tracking, project teams can focus on designing and improving how a user effectively moves through a site.

	
	
	
	
	
	
	

	



